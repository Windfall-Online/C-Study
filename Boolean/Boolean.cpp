// CPP_Study(Boolean).cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
using namespace std;
// 부리언(boolean) 참/거짓

bool isHighLevel = true;
bool isPlayer = true;
bool isMale = false;


// [Note]
// bool 은 1바이트 정수에 불과
// 어셈블리에 bool은 없다
// bool만 봐도 참/거짓 둘 중 하나라는 힌트를 줌 (가독성)
bool isFemale = 1;

// bool < 1바이트 정수
// -al 최하위 1바이트는 있었지만 1비트는 없음




// 실수 (부동소수점)
// 3.14
// . 앞/뒤를 기준으로 16/16으로 끊으면?

// 앞(0~65535) . 뒤(0~65535)
// 부동소수점(뜰 부 浮)
// 소수점이 둥둥 떠다닌다

// 3.1415926535 = 0.31415926535 * 10  or 314.15926535 * 10 ^ 2 
// 1)정규화 = 0.xxxx로시작하는거
// 2) 31415926535 (유효숫자) * 1 (지수)


// float 부호(1) 지수(8) 유효숫자(23) = 32비트 = 4바이트
// double 부호(1) 지수(11) 유효숫자(52) = 64비트 = 8바이트

float attackSpeed = -3.375f;				// 4바이트 int와 동일
double attackSpeed2 = 123.4123;			// 8바이트


// ex) -3.375라는 값을 저장
// 1) 2진수로 변환 = (3) + (0.375) = 0b11 + 0b0.011 = 0b11.011
// 0.375 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011
// 2) 2진수의 정규화  0b1.1011 앞자리가 1로 시작해야한다 그러므로 지수는 1 2^1
// 1(부호) 1(지수) 1011(유효숫자)
// 단 지수는 unsigned byte라고 가정하고 숫자 +127 만들어줌 128
//           2진/부호/지수
// 예상 결과 : 0b 1 10000000 1011 -> 뒤는 0으로 쭉 민다


// 프로그래밍할 때 부동소수점은 항상 '근사값' 이라는 걸 기억해야함.
// 1/3 = 0.3333333333333333333333333;
// 수가 커질 수록 오차 범위도 매우 커짐
// 실수 2개를 '=='으로 비교하는 것은 굉장히 위험하다.

int main()
{
	
	cout << isHighLevel << endl;
    
}
 