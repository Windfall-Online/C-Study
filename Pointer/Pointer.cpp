#include <iostream>
using namespace std;

// 오늘의 주제 : 포인터

int G_number = 0;



void SetHp(int* hp)
{
    *hp = 100;
}


// [매개변수][RET][지역변수(hp = 1)] [매개변수(지역변수 hp의 주소)][RET][지역변수]
// main의 hp와 sethp의 hp는 다름

int main()
{
    // 지금가지 사용한 방식
    // number라는 이름의 4바이트 정수 타입의 바구니  
    // number라는 변수를 스택 메모리에 할당
    // number = 1라 함은, number 바구니에 1이라는 숫자를 넣으라는 의미
    // 따라서 스택 메모리에 있는 특정 주소(number 바구니)에 우리가 원하는 값을 넣은 셈
    // number는 비유하자면 메모리에 이름을 붙인 것
    
    int hp = 1;
    SetHp(&hp);


    int number = 1;
   
    // TYPE* 변수이름;
    // 일단 2가지 요소
    // - TYPE
    // - *
   
    // 바구니는 바구니인데
    // [주소를 저장하는 바구니이다]
    // 변수 서넝ㄴ할 때 * 등장했다 -> 포인트 = 주소
    // ex) 포인터라는 바구니는 4바이트(32비트) or 8바이트(64비트) 고정 크기
    // 요즘은 64비트 운영체제에 게임도 64비트라 거진 8바이트

    int* ptr = &number;

    // 근데 남의 주소를 갖고 뭘 하라는거지?
    // 추가 문법 : [주소를 저장하는 바구니]가 가리키는 주소로 가서
    // 무엇인가를 해라!
    // *변수이름 = 값;
    
    // *이 붙으면 포탈을 타고 순간이동 한다고 생각해보자.
    // - 변수 선언(주소를 저장하는 바구니다!)
    // - 사용할 때(포탈 타고 순간이동)


    int value1 = *ptr;
    *ptr = 2;


    // TYPE은 왜 붙여줄까?
    // * = 포인터의 의미 = 주소를 저장하는 바구니 = 4 / 8바이트 고정 크기
    // *이 붙은 순간 고정크기인데 자료형이 무슨 소용인가?


    // 주소에 가면 뭐가 있는데?
    // ex) 결혼식 청접장에 있는 주소 = 예식장 주소
    // ex) 명함에 있는 주소 = 회사 주소
    // 각각 주소에가면 뭐가있다는걸 유추할 수 있어야 함.

    // 0b101010101111 <-얘를 분석하는 관점에따라 값이 달라짐
    // 포인터를 타고 갔을 때 뭐가있는지 TYPE으로 판별
    int* ptr2;

    // int로 가정하고 작업하라지 보장은 못함

    // 타입의 불일치
    __int64* ptr3 = (__int64*)&number;

    *ptr3 = 0xAABBCCDDEEFF;

    // 까보면 number는 4바이트인데
    // ptr3에 들어간값이 4바이트 초과라 추가로 2바이트를 밀어넣어서
    // 다른 주소에 값이 들어감

}

